# -*- coding: UTF-8 -*-
"""
 An app which is used to manage your time, likes Todo
    Copyright (C) 2025  ShengYan Cheng

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
# Icons by Font Awesome
# PROJECT_NAME Python_projects
# PRODUCT_NAME PyCharm
# NAME main
# AUTHOR Pfolg
# TIME 2025/3/3 10:25
import copy
import json

import os
import sys
import threading
import time
import webbrowser
from datetime import datetime, timedelta

import requests
from PyQt6 import uic, QtCore, QtWidgets
from PyQt6.QtCore import QDateTime
from PyQt6.QtGui import QPixmap, QIcon, QAction, QBrush, QColor
from PyQt6.QtWidgets import QApplication, QFrame, QLabel, QPushButton, QWidget, QScrollArea, QLineEdit, \
    QComboBox, QStatusBar, QFileDialog, QPlainTextEdit, QDateTimeEdit, QGroupBox, \
    QSpinBox, QTreeWidget, QTreeWidgetItem, QMessageBox, QToolButton, QSystemTrayIcon, QMenu, QTextEdit, \
    QCheckBox, QCommandLinkButton, QColorDialog, QSlider, QDateEdit
from plyer import notification

from CurriculumUI import CurriculumUI
from read_classes import ReadTable
from ShowDesktopTable import Window


def send_notification(message, title=None):
    # Generated by AI:DeepSeek, Changed by Pfolg
    if not title:
        title = appName + "通知"
    if send_message:
        notification.notify(
            title=title,
            message=message,
            app_name=appName,  # 应用名称
            timeout=5  # 通知显示时间（秒）
        )


def add_days(time_str, days):
    # Generated by AI:DeepSeek
    # 将时间字符串转换为datetime对象
    dt = datetime.strptime(time_str, "%Y/%m/%d %H:%M")
    # 增加指定天数
    new_dt = dt + timedelta(days=days)
    # 转换回原格式字符串
    return new_dt.strftime("%Y/%m/%d %H:%M")


def calculate_time_difference(time_str):
    # Generated by AI:DeepSeek, Changed by Pfolg
    # 将时间字符串转换为datetime对象
    now = datetime.now()
    _time = datetime.strptime(time_str, "%Y/%m/%d %H:%M")

    # 计算时间差（确保正数）
    delta = _time - now  # if _time > now else now - _time
    # 计算为秒
    # print(delta.days * 24 * 3600 + delta.seconds)
    return delta.days * 24 * 3600 + delta.seconds


def get_sort_key(item):
    # Generated by AI:DeepSeek
    """
    1. 未来的时间：按时间升序（离现在最近的排前面）

    2. 过去的时间：按时间降序（离现在最近的排前面）

    3. N/A的条目：排在最后
    """
    now = datetime.now()
    index, element = item
    ts = element['time_start']
    if ts == 'N/A':
        return (2, index)  # N/A组排在最后，保持原顺序
    try:
        dt = datetime.strptime(ts, "%Y/%m/%d %H:%M")
    except ValueError:
        return (2, index)

    if dt > now:
        # 未来时间组（组0），按时间升序排列
        return (0, dt.timestamp())
    else:
        # 过去时间组（组1），按时间降序排列
        return (1, -dt.timestamp())


def checkTag():
    # GitHub API的URL
    url = f'https://api.github.com/repos/Pfolg/PigFoolTimetable/releases'

    # 发送GET请求
    response = requests.get(url, verify=False)  # 不进行身份验证，可能会有风险

    # 检查请求是否成功
    if response.status_code == 200:
        # 解析JSON数据
        r = response.json()
        if r:
            release = [0]
            # 打印每个发布的信息
            # print(f"Release Tag: {release['tag_name']}")
            # print(f"Release Name: {release['name']}")
            # print(f"Release Date: {release['published_at']}")
            # print(f"Release Description: {release['body']}")
            if ver == release['tag_name']:
                infTxt = "当前是最新版！\n"

            else:
                infTxt = f"当前不是最新版！\t{ver}>>>{release['tag_name']}\n"

            QMessageBox.information(None, "设置",
                                    infTxt +
                                    f"Release Tag: {release['tag_name']}\n"
                                    f"Release Name: {release['name']}\n"
                                    f"Release Date: {release['published_at']}\n"
                                    f"Release Description: \n{release['body']}"
                                    )
        else:
            QMessageBox.information(None, "设置", "现在可能还未发布Release！")

    else:
        # print("Failed to retrieve data")
        QMessageBox.warning(None, "设置", "Failed to retrieve data.\n获取失败！")


class MainUI(QWidget):
    """自定义子界面类，封装 main_frame.ui 的逻辑"""

    def __init__(self, ui_file, parent=None):
        super().__init__(parent)
        # 直接将UI加载到当前实例
        ui_main = uic.loadUi(ui_file, self)
        self.frame: QFrame = ui_main.frame
        self.label: QLabel = ui_main.label
        self.treeWidget: QTreeWidget = ui_main.treeWidget
        self.btn_delete: QPushButton = ui_main.pushButton
        self.btn_add: QPushButton = ui_main.pushButton_2
        self.pushButton3: QPushButton = ui_main.pushButton_3
        self.pushButton4: QPushButton = ui_main.pushButton_4
        self.pushButton5: QPushButton = ui_main.pushButton_5
        self.treeWidget.expandAll()

    def btnFunction_convert(self, origin: list, target: list):
        try:
            _item = self.get_currentItem()
            if send_message:
                print("move", _item)
            for i in origin:
                # 确认事件是用户想移动的事件 4个关键参数
                if i.get("text") == _item[0] and i.get("time_start") == _item[2]:
                    if _item[1] in [i.get("text"), i.get("description")] and _item[3] in [
                        i.get("background_color"), "#000000"]:
                        origin.remove(i)
                        target.append(i)
                        send_notification("已移动事件 {}".format(_item[0]))
        except Exception:
            pass

    def btnFunction_delete(self, data: list):
        try:
            _item = self.get_currentItem()
            if send_message:
                print("delete", _item)
            for i in data:
                # 确认事件是用户想移除的事件 4个关键参数
                if i.get("text") == _item[0] and i.get("time_start") == _item[2]:
                    if _item[1] in [i.get("text"), i.get("description")] and _item[3] in [
                        i.get("background_color"), "#000000"]:
                        data.remove(i)
                        send_notification("已删除事件 {}".format(_item[0]))

        except Exception:
            pass

    def get_currentItem(self):
        try:
            currentThing = self.treeWidget.currentItem()
            """名称-描述-起始时间"""
            item = [currentThing.text(0), currentThing.toolTip(0), currentThing.text(1),
                    currentThing.background(0).color().name()]
            return item
        except Exception:
            # print("No item found")
            return []


class SettingUI(QWidget):
    """自定义子界面类，封装 setting.ui 的逻辑"""

    def __init__(self, ui_file, parent=None):
        super().__init__(parent)
        ui_main = uic.loadUi(ui_file, self)
        self.scrollArea: QScrollArea = ui_main.scrollArea
        self.scrollAreaWidgetContents: QWidget = ui_main.scrollAreaWidgetContents
        self.lineEdit: QLineEdit = ui_main.lineEdit
        self.bg_review: QLabel = ui_main.label_4
        self.comboBox: QComboBox = ui_main.comboBox
        self.pushButton: QPushButton = ui_main.pushButton
        self.pushButton_8: QPushButton = ui_main.pushButton_8
        self.toolButton: QToolButton = ui_main.toolButton

        self.pushButton_2: QPushButton = ui_main.pushButton_2
        self.pushButton_3: QPushButton = ui_main.pushButton_3
        self.pushButton_4: QPushButton = ui_main.pushButton_4
        self.pushButton_5: QPushButton = ui_main.pushButton_5
        self.pushButton_6: QPushButton = ui_main.pushButton_6
        self.pushButton_7: QPushButton = ui_main.pushButton_7
        self.pushButton_9: QPushButton = ui_main.pushButton_9
        self.pushButton_10: QPushButton = ui_main.pushButton_10
        self.pushButton_11: QPushButton = ui_main.pushButton_11
        self.spinBox: QSpinBox = ui_main.spinBox
        # logo
        self.lineEdit2: QLineEdit = ui_main.lineEdit_2
        self.label_logo: QLabel = ui_main.label_6
        # Curriculum
        self.checkBox_3: QCheckBox = ui_main.checkBox_3
        self.checkBox_4: QCheckBox = ui_main.checkBox_4
        self.checkBox_5: QCheckBox = ui_main.checkBox_5
        self.lineEdit_3: QLineEdit = ui_main.lineEdit_3
        self.pushButton_12: QPushButton = ui_main.pushButton_12
        self.commandLinkButton: QCommandLinkButton = ui_main.commandLinkButton
        self.checkBox: QCheckBox = ui_main.checkBox
        self.checkBox_2: QCheckBox = ui_main.checkBox_2
        self.horizontalSlider: QSlider = ui_main.horizontalSlider
        self.horizontalSlider_2: QSlider = ui_main.horizontalSlider_2
        self.dateEdit: QDateEdit = ui_main.dateEdit

        self.pushButton_13: QPushButton = ui_main.pushButton_13
        self.pushButton_14: QPushButton = ui_main.pushButton_14

        # 按钮功能绑定
        self.pushButton_2.clicked.connect(self.how_to_startUp)
        self.pushButton_3.clicked.connect(self.open_current_folder)
        self.pushButton_4.clicked.connect(lambda: self.open_current_folder("data.json"))
        self.pushButton_7.clicked.connect(self.open_website)
        self.toolButton.clicked.connect(self.clear_icon_path)
        self.comboBox.currentTextChanged.connect(self.clear_icon_path)
        self.lineEdit_3.returnPressed.connect(self.select_excel)
        self.pushButton_12.clicked.connect(self.select_excel)
        self.checkBox_3.checkStateChanged.connect(self.changeCurriculumStatus)
        self.pushButton_13.clicked.connect(lambda: os.system("start ./assets/timeline.txt"))
        self.commandLinkButton.clicked.connect(lambda: os.system("start ./assets/format.png"))
        self.changeCurriculumStatus()

    def changeCurriculumStatus(self):
        flag = self.checkBox_3.isChecked()
        self.checkBox_4.setEnabled(flag)
        self.checkBox_5.setEnabled(flag)
        self.lineEdit_3.setEnabled(flag)
        self.pushButton_12.setEnabled(flag)
        self.commandLinkButton.setEnabled(flag)
        self.dateEdit.setEnabled(flag)
        self.horizontalSlider.setEnabled(flag)
        self.horizontalSlider_2.setEnabled(flag)
        self.pushButton_13.setEnabled(flag)
        self.pushButton_14.setEnabled(flag)
        # QMessageBox.critical(None, "设置", "开发失败，后面技术进步了再来！\n该模块目前无法正常使用......")

    def select_excel(self):
        fd = QFileDialog()
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)  # 设置文件单选
        # fd.getExistingDirectory()
        fd.setNameFilter("*.xlsx")
        if fd.exec():
            self.lineEdit_3.setText(*fd.selectedFiles())

    def select_file(self, data: dict):
        """选择背景文件"""
        fd = QFileDialog()
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)  # 设置文件单选
        # fd.getExistingDirectory()
        fd.setNameFilter("*.jpg *.png *.svg *.bmp")
        if fd.exec():
            p = fd.selectedFiles()[0]
            self.lineEdit2.setText(p)
            self.label_logo.setPixmap(QPixmap(p))
            data["tray_logo"] = p
            print(*fd.selectedFiles(), "selected!")

    def clear_icon_path(self):
        self.lineEdit.clear()

    @staticmethod
    def how_to_startUp():
        r = QMessageBox.information(
            None, "帮助", "扣咩啦噻~\n懒得用代码实现，自己在网上搜教程",
            QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Help)
        if r == QMessageBox.StandardButton.Help:
            webbrowser.open("https://blog.csdn.net/qq_41554005/article/details/120947070")

    @staticmethod
    def open_current_folder(path=None):
        if not path:
            path = os.getcwd()
        try:
            os.startfile(path)
        except FileNotFoundError:
            pass

    @staticmethod
    def open_website():
        webbrowser.open(official_website)


class AddItemUI:
    def __init__(self, ui_file, data: dict):
        self.data = data
        self.ui_main = uic.loadUi(ui_file)
        self.line_name: QLineEdit = self.ui_main.lineEdit
        self.ico_path: QLineEdit = self.ui_main.lineEdit_2
        self.pushButton: QPushButton = self.ui_main.pushButton
        self.hand_up: QPushButton = self.ui_main.pushButton_2
        self.icon_label: QLabel = self.ui_main.label_4
        self.plainTextEdit: QPlainTextEdit = self.ui_main.plainTextEdit
        self.dateTimeEdit: QDateTimeEdit = self.ui_main.dateTimeEdit
        self.dateTimeEdit_2: QDateTimeEdit = self.ui_main.dateTimeEdit_2
        self.groupBox: QGroupBox = self.ui_main.groupBox
        self.spinBox: QSpinBox = self.ui_main.spinBox
        self.spinBox_2: QSpinBox = self.ui_main.spinBox_2
        self.comboBox: QComboBox = self.ui_main.comboBox
        # color
        self.label_9: QLabel = self.ui_main.label_9
        self.label_10: QLabel = self.ui_main.label_10
        self.pushButton_3: QPushButton = self.ui_main.pushButton_3
        self.pushButton_4: QPushButton = self.ui_main.pushButton_4
        self.currentTime = QDateTime.currentDateTime()  # 使用当前时间作为默认时间
        self.set()

    @staticmethod
    def selectColor(label: QLabel, color_type):
        # 弹出颜色对话框并获取颜色
        color = QColorDialog.getColor()

        if color.isValid():
            # 获取颜色信息
            hex_color = color.name()  # 十六进制字符串，如 "#ff0000"
            # rgb = color.getRgb()  # 元组 (R, G, B, A)
            # rgba_normalized = color.getRgbF()  # 浮点数元组 (0-1范围)

            # print(f"十六进制: {hex_color}")
            # print(f"RGB(A) 值: {rgb}")
            # print(f"标准化 RGBA: {rgba_normalized}")
            label.setToolTip(hex_color)
            if color_type == "fg":
                label.setStyleSheet(f"color:{hex_color};")
            elif color_type == "bg":
                label.setStyleSheet(f"background-color:{hex_color};")

    def set(self):
        self.comboBox.addItems(["进行中", "计划", "已完成"])
        self.comboBox.setCurrentText("计划")
        self.pushButton.clicked.connect(lambda: self.select_file(self.ico_path))
        self.ico_path.returnPressed.connect(lambda: self.select_file(self.ico_path))
        self.hand_up.clicked.connect(self.hand_information)
        self.pushButton_3.clicked.connect(lambda: self.selectColor(self.label_9, "fg"))
        self.pushButton_4.clicked.connect(lambda: self.selectColor(self.label_10, "bg"))
        self.dateTimeEdit.setDateTime(self.currentTime)
        self.dateTimeEdit_2.setDateTime(self.currentTime)

    def select_file(self, box: QLineEdit):
        """选择背景文件"""
        fd = QFileDialog()
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)  # 设置文件单选
        # fd.getExistingDirectory()
        fd.setNameFilter("*.jpg *.png *.svg")
        if fd.exec():
            box.setText(*fd.selectedFiles())
            self.icon_label.setPixmap(QPixmap(*fd.selectedFiles()))

    def hand_information(self):
        kind = self.comboBox.currentText()
        name = self.line_name.text()
        if name:
            icon = self.ico_path.text()
            description = self.plainTextEdit.toPlainText()
            time_start = self.dateTimeEdit.text()
            time_end = self.dateTimeEdit_2.text()
            color_fg = self.label_9.toolTip()
            color_bg = self.label_10.toolTip()
            if color_fg == "#000000":
                color_fg = None
            if color_bg == "#ffffff":
                color_bg = None
            if time_start == time_end == self.currentTime.toString("yyyy/M/d HH:mm"):
                time_start = time_end = "N/A"  # 如果时间为当前时间，则为N/A
            if self.groupBox.isChecked():
                repeat = True
                number = self.spinBox.value()
                circle = self.spinBox_2.value()
            else:
                repeat = False
                number = 0
                circle = 0
            _data = {
                "text": name,
                "icon": icon,
                "description": description,
                "time_start": time_start,
                "time_end": time_end,
                "foreground_color": color_fg,
                "background_color": color_bg,
                "repeat": repeat,
                "repeat_number": number,
                "repeat_space": circle
            }
            # print(_data)
            if kind == "进行中":
                self.data["doing"].append(_data)
            elif kind == "计划":
                self.data["plan"].append(_data)
            elif kind == "已完成":
                self.data["done"].append(_data)
            indexed_data1 = list(enumerate(self.data["doing"]))
            indexed_data2 = list(enumerate(self.data["plan"]))
            indexed_data3 = list(enumerate(self.data["done"]))
            # 排序数据
            sorted_indexed1 = sorted(indexed_data1, key=get_sort_key)
            sorted_indexed2 = sorted(indexed_data2, key=get_sort_key)
            sorted_indexed3 = sorted(indexed_data3, key=get_sort_key)
            # 提取排序后的元素
            self.data["doing"] = [item[1] for item in sorted_indexed1]
            self.data["plan"] = [item[1] for item in sorted_indexed2]
            self.data["done"] = [item[1] for item in sorted_indexed3]
        self.ui_main.close()
        send_notification("事件已成功添加至{}".format(kind))

    def show(self):
        self.ui_main.show()


def read_bg_folder():
    bg_folder = "assets/bgs"
    if os.path.exists(bg_folder):
        i = os.walk(bg_folder)
        return list(i)[0][2]
    else:
        return []


class ReviewUI(QWidget):
    """自定义子界面类"""

    def __init__(self, ui_file, parent=None):
        super().__init__(parent)
        ui_main = uic.loadUi(ui_file, self)
        self.label: QLabel = ui_main.label
        self.label2: QLabel = ui_main.label_2
        self.label3: QLabel = ui_main.label_3
        self.textEdit: QTextEdit = ui_main.textEdit
        self.pushButton: QPushButton = ui_main.pushButton


class MainWindow(QtWidgets.QMainWindow):
    # Generated by AI:DeepSeek
    def __init__(self, ui_file):
        super(MainWindow, self).__init__()
        # 动态加载 .ui 文件
        uic.loadUi(ui_file, self)

    # 重写关闭事件以隐藏窗口而不是销毁它
    def closeEvent(self, event):
        self.hide()
        event.ignore()


def readTextFile(file):
    if os.path.exists(file):
        with open(file, "r", encoding="utf-8") as f:
            return f.read()
    else:
        return


class TimeTableApp:
    def __init__(self, version=None):
        global send_message
        self.add_item_window = None
        self.version = version
        self.notify_time = 300
        self.uis = [
            "./assets/uis/",
            "main.ui",
            "main_frame.ui",
            "setting.ui",
            "add_item.ui",
            "review.ui",
            "class_table.ui",
            "deskwin.ui"
        ]
        # 建立数据储存对象——字典
        self.data = {
            "doing": [],
            "plan": [],
            "done": [],
            "classes": [],
            "setting": {}
        }
        """核心数据读取"""
        # 检查ui文件完整
        check = self.checkUiFiles()
        if not check:
            print("ui文件缺失，程序退出！")
            time.sleep(10)
            sys.exit()
        # 读取data
        self.read_data()
        # 读取设置然后设置
        self.read_setting()

        # 加载主界面
        self.app = QApplication(sys.argv)
        if self.data["setting"].get("X_hide"):
            self.main_ui = MainWindow(self.uis[0] + self.uis[1])
        else:
            self.main_ui = uic.loadUi(self.uis[0] + self.uis[1])

        primary_screen = self.app.primaryScreen()
        screen_geometry = primary_screen.geometry()  # 包括任务栏的区域
        self.screen_width, self.screen_height = screen_geometry.width(), screen_geometry.width()

        # 设定浮窗
        # self.float_win = Window(self.uis[0] + self.uis[7])

        self.doing_frame = MainUI(self.uis[0] + self.uis[2], parent=self.main_ui)
        self.plan_frame = MainUI(self.uis[0] + self.uis[2], parent=self.main_ui)
        self.done_frame = MainUI(self.uis[0] + self.uis[2], parent=self.main_ui)
        self.setting_frame = SettingUI(self.uis[0] + self.uis[3], parent=self.main_ui)
        self.readMe_License = ReviewUI(self.uis[0] + self.uis[5], parent=self.main_ui)
        self.curriculum_frame = CurriculumUI(self.uis[0] + self.uis[6], parent=self.main_ui)
        self.pushButton: QPushButton = self.main_ui.pushButton
        self.pushButton_2: QPushButton = self.main_ui.pushButton_2
        self.pushButton_3: QPushButton = self.main_ui.pushButton_3
        self.pushButton_4: QPushButton = self.main_ui.pushButton_4
        self.pushButton_5: QPushButton = self.main_ui.pushButton_5
        # 状态栏
        self.time_label = QLabel()
        self.statusbar: QStatusBar = self.main_ui.statusbar
        # 背景
        self.bg: QLabel = self.main_ui.label

        # 创建系统托盘图标
        self.tray_icon = QSystemTrayIcon()
        self.tray_icon.setIcon(QIcon(QPixmap("assets/logo.png")))

        # 初始化

        """对主要frames进行设定"""
        self.frame_setup()
        self.show_frame_doing()
        """主要按钮功能绑定"""
        self.function_btns()
        """设置状态栏"""
        self.set_statusbar()
        """刷新状态栏时间"""
        threading.Thread(target=self.td_changeTimeLabel, daemon=True).start()
        """往列表添加项目"""
        threading.Thread(target=self.td_addData, daemon=True).start()
        """自动移动事件和提醒"""
        threading.Thread(target=self.td_autoMoveEvent, daemon=True).start()
        """课程表刷新"""
        threading.Thread(target=self.td_setCurriculum, daemon=True).start()

        self.doing_frame.setVisible(True)
        """设置设置界面"""
        self.set_SettingFrame()
        """更改界面背景&预览图"""
        self.change_bg(all_change=True)
        """托盘设定"""
        self.set_tray()
        """桌面课表刷新"""
        # threading.Thread(target=self.td_addItemToWin, daemon=True).start()

        # 显示主界面
        self.main_ui.show()
        # 显示浮窗
        # self.float_win.show()
        # 显示托盘图标
        self.tray_icon.show()
        """显示系统通知
        self.tray_icon.showMessage(
            "TimeTable",  # 标题
            "应用启动&初始化成功",  # 内容
            QSystemTrayIcon.MessageIcon.Information,  # 图标类型
            5000  # 显示时长（毫秒）
        )
        """
        # self.showOnDesktop()
        sys.exit(self.app.exec())

    def td_addItemToWin(self):
        time.sleep(5)
        self.float_win = None
        self.float_win = Window(self.uis[0] + self.uis[7])
        while True:
            print(1)
            desk_data = []
            for k in self.data.get("classes"):
                if time.strftime("%Y/%m/%d") == k.get("time_start").split(" ")[0] and calculate_time_difference(
                        k.get("time_end")) > 0:
                    if k not in desk_data:
                        desk_data.append(k)
            self.float_win.addItemInWin(desk_data)
            print(2)
            self.float_win.show()
            time.sleep(10)

    def changeFloatWinLocation(self):
        x = self.setting_frame.horizontalSlider.value()
        y = self.setting_frame.horizontalSlider_2.value()
        self.float_win.setLocation(x, y)
        self.data["setting"]["win_location"] = [x, y]

    def td_setCurriculum(self):
        old_data = None
        while True:
            if self.data.get("classes"):
                if self.data.get("classes") != old_data:
                    old_data = copy.deepcopy(self.data.get("classes"))
                    _data = []
                    for i in self.data["classes"]:
                        k = copy.deepcopy(i)
                        repeat_number = i.get("repeat_number")
                        start = i.get("time_start")
                        end = i.get("time_end")
                        while calculate_time_difference(start) <= 0 or repeat_number == 0:
                            start = add_days(start, 7)
                            end = add_days(end, 7)
                            repeat_number -= 1

                        # print(calculate_time_difference(start)
                        k["repeat_number"] = repeat_number
                        k["time_start"] = start
                        k["time_end"] = end
                        _data.append(k)
                        # 将今天的课加入计划
                        if time.strftime("%Y/%m/%d") == k.get("time_start").split(" ")[0]:
                            # desk_data = []
                            # if k not in desk_data:
                            #     desk_data.append(k)
                            # self.float_win.addItemInWin(desk_data)
                            if k not in self.data["plan"]:
                                self.data["plan"].append(k)
                    self.data["classes"] = _data
                    indexed_data = list(enumerate(self.data["classes"]))
                    # 排序数据
                    sorted_indexed = sorted(indexed_data, key=get_sort_key)
                    # 提取排序后的元素
                    self.data["classes"] = [item[1] for item in sorted_indexed]
                    self.curriculum_frame.setTable(self.data["classes"])
            time.sleep(1)

    def showOnDesktop(self):
        flag = self.setting_frame.checkBox_4.isChecked()
        self.data["setting"]["ShowOnDesk"] = flag
        # self.float_win.setVisible(flag)
        QMessageBox.critical(None, "设置", "此模块开发时遇到了问题，目前无法使用！")

    # def isTop(self):
    #     flag = self.setting_frame.checkBox_5.isChecked()
    #     self.data["setting"]["isTop"] = flag

    def add_classes(self):
        xlsx = self.setting_frame.lineEdit_3.text()
        first_day = self.setting_frame.dateEdit.text()
        # print(first_day)
        new_data = []
        if xlsx and os.path.exists("assets/timeline.txt"):
            data = ReadTable(xlsx, "assets/timeline.txt").addColor()
            for item in data:
                www = copy.deepcopy(item)
                if item.get("time_start") and item.get("weekday") and item.get("week") and item.get("time_end"):
                    this_week_day = item.get("weekday") - 1
                    this_time_start = item.get("time_start")
                    this_time_end = item.get("time_end")
                    www["time_start"] = add_days(first_day + " " + this_time_start, this_week_day)
                    www["time_end"] = add_days(first_day + " " + this_time_end, this_week_day)
                    new_data.append(www)
            self.data["classes"] = new_data
            send_notification("已成功导入数据！")
        else:
            if not xlsx:
                QMessageBox.critical(None, appName, "你必须选择一个 .xlsx 文件才能进行分析！")
            else:
                QMessageBox.critical(None, appName, "找不到 timeline.txt 请确认文件是否存在于 assets 内！")

    def read_setting(self):
        global send_message
        if self.data["setting"].get("notify"):
            send_message = True
        else:
            send_message = False
        notify_time = self.data["setting"].get("notify_time")
        if notify_time or notify_time == 0:
            self.notify_time = notify_time

    def td_autoMoveEvent(self):
        try:
            notified_data1 = []
            notified_data2 = []
            while True:
                for event in self.data["plan"]:
                    start_time = event.get("time_start")
                    if start_time and start_time != "N/A":
                        a = calculate_time_difference(start_time)
                        if a == self.notify_time:
                            if event not in notified_data1:
                                notified_data1.append(event)
                                send_notification(
                                    "事件 {} 即将于 {} 分钟后开始！".format(event.get("text"),
                                                                           int(self.notify_time / 60)))
                                self.statusbar.showMessage(
                                    "事件 {} 即将于 {} 分钟后开始！".format(event.get("text"),
                                                                           int(self.notify_time / 60)),
                                    3000)
                        elif a == 0:
                            if event not in notified_data2:
                                notified_data2.append(event)
                                send_notification("事件 {} 开始进行！".format(event.get("text")))
                                self.statusbar.showMessage("事件 {} 开始进行！".format(event.get("text")), 3000)
                                self.data["plan"].remove(event)
                                self.data["doing"].append(event)
                        # 移除已经过期的课程
                        if calculate_time_difference(event.get("time_end")) <= 0 and event.get("weekday"):
                            self.data["plan"].remove(event)
                for event in self.data["doing"]:
                    end_time = event.get("time_end")
                    if end_time and end_time != "N/A":
                        if calculate_time_difference(end_time) == 0:
                            # 一般情况
                            if event.get("repeat_number") == 0:
                                send_notification("事件 {} 已结束！".format(event.get("text")))
                                self.statusbar.showMessage("事件 {} 已结束！".format(event.get("text")), 3000)
                                self.data["doing"].remove(event)
                                # 如果不是课程就直接从“doing”删除
                                if not event.get("weekday"):
                                    self.data["done"].append(event)
                            else:
                                rn = event.get("repeat_number") - 1
                                ts = event.get("time_start")
                                rs = event.get("repeat_space")
                                te = event.get("time_end")
                                # 深拷贝防止出现假货
                                new_event = copy.deepcopy(event)
                                new_event["repeat_number"] = rn
                                new_event["time_start"] = add_days(ts, rs)
                                new_event["time_end"] = add_days(te, rs)
                                self.data["doing"].remove(event)
                                self.data["plan"].append(new_event)
                                send_notification("本次的事件 {} 已结束！".format(event.get("text")))
                            # 移除已经过期的课程
                            if calculate_time_difference(event.get("time_end")) <= 0 and event.get("weekday"):
                                self.data["doing"].remove(event)

                time.sleep(1)
        except RuntimeError:
            pass

    def checkUiFiles(self):
        base = self.uis[0]
        for i in self.uis:
            if i == base:
                continue
            elif os.path.exists(base + i):
                if i == self.uis[-1]:
                    return True
            else:
                return False

    def changeCurriculumStatus(self):
        flag = self.setting_frame.checkBox_3.isChecked()
        # self.pushButton_5.setEnabled(flag)
        self.pushButton_5.setVisible(flag)
        self.data["setting"]["EnableCurriculum"] = flag

    def changeTrayIcon(self):
        logo = self.setting_frame.lineEdit2.text()
        if logo:
            self.tray_icon.setIcon(QIcon(logo))
            self.data["setting"]["tray_logo"] = logo

    def show_readMe_License(self, psg_type, psg):
        self.frame_hideAll()
        self.readMe_License.setVisible(True)
        self.readMe_License.textEdit.setReadOnly(False)
        self.readMe_License.pushButton.clicked.connect(self.show_frame_setting)
        self.readMe_License.label.setText(psg_type)
        print(psg, psg_type)
        if psg_type == "LICENSE" and psg:
            self.readMe_License.textEdit.setMarkdown(psg)
            self.readMe_License.label2.setText("请以官网的许可证为准！")
            self.readMe_License.label3.setText("继续使用本软件，即表示您同意此{}".format(psg_type))
        elif psg_type == "README" and psg:
            self.readMe_License.textEdit.setMarkdown("Please see .\\README.md or view it on website.")
            self.readMe_License.label2.setText("请以官网的自述文件为准！")
            self.readMe_License.label3.setText("")
        else:
            self.readMe_License.textEdit.setPlainText("No information!")
            self.readMe_License.label2.setText("文件缺失，可前往官网阅读！")
            self.readMe_License.label3.setText("您现在无法读取LICENSE，当前默认您同意我们的LICENSE")
        self.readMe_License.textEdit.setReadOnly(True)

    def set_tray(self):
        # 创建右键菜单
        menu = QMenu()
        # 添加菜单项
        show_action = QAction("界面", self.app)
        show_action.setIcon(QIcon("assets/icons/window-restore.svg"))
        exit_action = QAction("退出", self.app)
        exit_action.setIcon(QIcon("assets/icons/circle-dot.svg"))
        # 链接功能
        show_action.triggered.connect(self.main_ui.show)
        exit_action.triggered.connect(sys.exit)
        # 加入动作
        menu.addAction(show_action)
        menu.addAction(exit_action)

        self.tray_icon.setToolTip("{}".format(appName))

        # 核心功能：绑定激活信号
        # self.tray_icon.activated.connect(self.main_ui.show)

        self.tray_icon.setContextMenu(menu)

    def read_data(self):
        if os.path.exists("data.json"):
            with open("data.json", "r", encoding="utf-8") as file:
                self.data: dict = json.load(file)

    def clear_data(self):
        """清除数据"""
        self.data["doing"] = []
        self.data["plan"] = []
        self.data["done"] = []
        self.data["classes"] = []

    def td_addData(self):
        """循环将数据加入列表"""
        try:
            data_old = None
            while True:
                if self.data != data_old:
                    data_old = copy.deepcopy(self.data)
                    self.add_items(self.doing_frame.treeWidget, self.data["doing"])
                    time.sleep(.1)
                    self.add_items(self.plan_frame.treeWidget, self.data["plan"])
                    time.sleep(.1)
                    self.add_items(self.done_frame.treeWidget, self.data["done"])
                    time.sleep(.1)
                    with open("data.json", "w", encoding="utf-8") as file:
                        json.dump(self.data, file, indent=4, ensure_ascii=False)
                    if send_message:
                        print("write date in list......")
                time.sleep(2)
        except Exception:
            pass

    def show_add_window(self, data: dict):
        self.add_item_window = None
        self.add_item_window = AddItemUI(self.uis[0] + self.uis[4], data)
        self.add_item_window.show()

    # 核心数据添加函数
    def add_items(self, listW: QTreeWidget, data: list):
        """
        data={
            text:"",
            icon:"",
            description:""
            time_start:"",
            time_end:"",
            foreground_color:""
            background_color:""
            repeat:bool,
            repeat_number:int,
            repeat_space:day/int
        }
        """
        # 为每个元素添加索引以保持N/A组的原始顺序
        indexed_data = list(enumerate(data))
        # 排序数据
        sorted_indexed = sorted(indexed_data, key=get_sort_key)
        # 提取排序后的元素
        data = [item[1] for item in sorted_indexed]
        listW.clear()  # 清空列表
        if data:
            for item in data:
                a = QTreeWidgetItem(listW)
                _text = ""
                if item.get("text"):
                    a.setText(0, item.get("text"))
                else:
                    a.setText(0, "Unknown")
                if item.get("icon"):
                    a.setIcon(0, QIcon(item.get("icon")))
                if item.get("description"):
                    a.setToolTip(0, item.get("description"))
                else:  # 如果没有备注就用标题
                    a.setToolTip(0, item.get("text"))
                if item.get("foreground_color"):
                    for i in range(5):
                        a.setForeground(i, QBrush(QColor(item.get("foreground_color"))))
                if item.get("background_color"):
                    for i in range(5):
                        a.setBackground(i, QBrush(QColor(item.get("background_color"))))

                if item.get("time_start"):
                    a.setText(1, item.get("time_start"))
                if item.get("time_end"):
                    a.setText(2, item.get("time_end"))
                a.setText(3, str(item.get("repeat_number")))
                a.setText(4, str(item.get("repeat_space")))
                self.statusbar.showMessage("已刷新列表", 5000)

    def set_SettingFrame(self):
        """设置设置界面"""
        if send_message:
            print("Reading backgrounds......")
        bgs = read_bg_folder()
        self.setting_frame.comboBox.addItems(bgs)
        self.setting_frame.comboBox.setCurrentText("simple.png")

        if send_message:
            self.setting_frame.checkBox.setChecked(True)
        else:
            self.setting_frame.checkBox.setChecked(False)
        if self.data["setting"].get("X_hide"):
            self.setting_frame.checkBox_2.setChecked(True)
        else:
            self.setting_frame.checkBox_2.setChecked(False)
        if self.data["setting"].get("EnableCurriculum"):
            self.setting_frame.checkBox_3.setChecked(True)
        else:
            self.setting_frame.checkBox_3.setChecked(False)
        if self.data["setting"].get("ShowOnDesk"):
            self.setting_frame.checkBox_4.setChecked(True)
        else:
            self.setting_frame.checkBox_4.setChecked(False)
            # self.float_win.setVisible(False)

        # if self.data["setting"].get("isTop"):
        #     self.setting_frame.checkBox_5.setChecked(True)
        # else:
        #     self.setting_frame.checkBox_5.setChecked(False)
        self.setting_frame.checkBox_2.checkStateChanged.connect(self.isXHide)
        if self.data["setting"].get("background"):
            bg = self.data["setting"].get("background")
            self.setting_frame.lineEdit.setText(bg)
            self.setting_frame.comboBox.setCurrentText(bg.split("/")[-1])

        self.setting_frame.comboBox.currentTextChanged.connect(lambda: self.change_bg(False, True))
        self.setting_frame.pushButton.clicked.connect(lambda: self.change_bg(True))
        self.setting_frame.lineEdit.returnPressed.connect(lambda: self.select_file(self.setting_frame.lineEdit))
        self.setting_frame.pushButton_8.clicked.connect(lambda: self.select_file(self.setting_frame.lineEdit))
        self.setting_frame.spinBox.setValue(int(self.notify_time / 60))
        self.setting_frame.spinBox.valueChanged.connect(self.isNotify)
        self.setting_frame.pushButton_14.clicked.connect(self.add_classes)
        self.setting_frame.checkBox_4.checkStateChanged.connect(self.showOnDesktop)
        self.setting_frame.checkBox_5.setVisible(False)
        # 检查更新
        self.setting_frame.pushButton_6.clicked.connect(checkTag)
        # self.setting_frame.checkBox_5.checkStateChanged.connect(self.isTop)
        # 移动浮窗在屏幕上的位置
        self.setting_frame.horizontalSlider.setMaximum(self.screen_width)
        self.setting_frame.horizontalSlider_2.setMaximum(self.screen_height)
        # self.setting_frame.horizontalSlider.valueChanged.connect(self.changeFloatWinLocation)
        # self.setting_frame.horizontalSlider_2.valueChanged.connect(self.changeFloatWinLocation)
        if self.data["setting"].get("win_location"):
            x, y = self.data["setting"].get("win_location")
            self.setting_frame.horizontalSlider.setValue(x)
            self.setting_frame.horizontalSlider_2.setValue(y)

    def show_floatWin(self):
        time.sleep(3)
        self.float_win.show()
        if send_message:
            print("show float window")

    def select_file(self, box: QLineEdit):
        """选择背景文件"""
        fd = QFileDialog()
        fd.setFileMode(QFileDialog.FileMode.ExistingFile)  # 设置文件单选
        # fd.getExistingDirectory()
        fd.setNameFilter("*.jpg *.png")
        if fd.exec():
            box.setText(*fd.selectedFiles())
            self.change_bg()
            print(*fd.selectedFiles(), "selected!")

    def change_bg(self, all_change=False, review=False):
        """更改界面背景&预览图"""
        if not review:  # 如果不是预览预设壁纸就获取用户壁纸
            user_bg = self.setting_frame.lineEdit.text()
        else:
            user_bg = ""
        default_bg = "assets/bgs/" + self.setting_frame.comboBox.currentText()
        if user_bg:  # 有用户壁纸就预览
            self.setting_frame.bg_review.setPixmap(QPixmap(user_bg))
        else:  # 预览预设壁纸
            self.setting_frame.bg_review.setPixmap(QPixmap(default_bg))
        if all_change and user_bg:  # 设定全局用户自定义壁纸&保存数据
            self.bg.setPixmap(QPixmap(user_bg))
            self.data["setting"]["background"] = user_bg
        elif all_change and default_bg:  # 设定全局预设壁纸&保存数据
            self.bg.setPixmap(QPixmap(default_bg))
            self.data["setting"]["background"] = default_bg

    def td_changeTimeLabel(self):
        """刷新状态栏时间"""
        while True:
            try:
                self.time_label.setText(time.strftime("%Y-%m-%d %H:%M:%S"))
            except RuntimeError:
                pass
            time.sleep(.4)

    def set_statusbar(self):
        """状态栏设定"""
        self.statusbar.addPermanentWidget(self.time_label)
        self.statusbar.addPermanentWidget(QLabel("ver {}".format(self.version)))
        if send_message:
            print("statusbar\'s setup is completed!")

    def function_btns(self):
        """"主要按钮功能绑定"""
        self.pushButton.clicked.connect(self.show_frame_doing)
        self.pushButton_2.clicked.connect(self.show_frame_plan)
        self.pushButton_3.clicked.connect(self.show_frame_done)
        self.pushButton_4.clicked.connect(self.show_frame_setting)
        self.pushButton_5.clicked.connect(self.show_frame_curriculum)
        # 待修改
        self.pushButton_5.setVisible(False)
        self.setting_frame.pushButton_5.clicked.connect(self.clear_data)
        self.setting_frame.checkBox_3.checkStateChanged.connect(self.changeCurriculumStatus)
        # 自述文件和许可证
        self.setting_frame.pushButton_9.clicked.connect(
            lambda: self.show_readMe_License("README", readTextFile("README.md")))
        self.setting_frame.pushButton_10.clicked.connect(
            lambda: self.show_readMe_License("LICENSE", readTextFile("LICENSE.txt")))
        # logo设定绑定
        self.setting_frame.lineEdit2.returnPressed.connect(lambda: self.setting_frame.select_file(self.data["setting"]))
        self.setting_frame.pushButton_11.clicked.connect(self.changeTrayIcon)
        # setting通知
        self.setting_frame.checkBox.checkStateChanged.connect(self.isNotify)
        logo = self.data["setting"].get("tray_logo")
        if logo:
            self.setting_frame.lineEdit2.setText(logo)
            self.setting_frame.label_logo.setPixmap(QPixmap(logo))
            self.tray_icon.setIcon(QIcon(logo))
        if send_message:
            print("Main btns' setup is completed!")

    def isNotify(self):
        global send_message
        flag = self.setting_frame.checkBox.isChecked()
        notify_time = self.setting_frame.spinBox.value()
        if send_message:
            print("send_message:", flag)
        self.data["setting"]["notify"] = flag
        self.data["setting"]["notify_time"] = notify_time * 60
        send_message = flag

    def isXHide(self):
        flag = self.setting_frame.checkBox_2.isChecked()
        self.data["setting"]["X_hide"] = flag

    def show_frame_curriculum(self):
        self.frame_hideAll()
        self.curriculum_frame.setVisible(True)
        if send_message:
            print("curriculum_frame.setVisible=True")

    def show_frame_doing(self):
        self.frame_hideAll()
        self.doing_frame.setVisible(True)
        if send_message:
            print("doing_frame.setVisible=True")

    def show_frame_plan(self):
        self.frame_hideAll()
        self.plan_frame.setVisible(True)
        if send_message:
            print("plan_frame.setVisible=True")

    def show_frame_done(self):
        self.frame_hideAll()
        self.done_frame.setVisible(True)
        if send_message:
            print("done_frame.setVisible=True")

    def show_frame_setting(self):
        self.frame_hideAll()
        self.setting_frame.setVisible(True)
        if send_message:
            print("setting_frame.setVisible=True")

    def frame_setup(self):
        """"对主要frame进行设定"""
        for frame in [
            self.doing_frame, self.plan_frame, self.done_frame, self.setting_frame, self.readMe_License,
            self.curriculum_frame]:
            frame.setGeometry(QtCore.QRect(170, 30, 610, 540))
        # 设定列表标题
        header = ["名称", "起始", "结束", "重复/次", "周期/天"]
        self.doing_frame.treeWidget.setHeaderLabels(header)
        self.plan_frame.treeWidget.setHeaderLabels(header)
        self.done_frame.treeWidget.setHeaderLabels(header)
        self.doing_frame.label.setText("正在进行")
        self.doing_frame.pushButton3.setEnabled(False)
        self.plan_frame.label.setText("计划")
        self.plan_frame.pushButton4.setEnabled(False)
        self.done_frame.label.setText("已完成")
        self.done_frame.pushButton5.setEnabled(False)
        # 设定转换按钮
        self.doing_frame.pushButton4.clicked.connect(
            lambda: self.doing_frame.btnFunction_convert(self.data["doing"], self.data["plan"]))
        self.doing_frame.pushButton5.clicked.connect(
            lambda: self.doing_frame.btnFunction_convert(self.data["doing"], self.data["done"]))
        self.plan_frame.pushButton3.clicked.connect(
            lambda: self.plan_frame.btnFunction_convert(self.data["plan"], self.data["doing"]))
        self.plan_frame.pushButton5.clicked.connect(
            lambda: self.plan_frame.btnFunction_convert(self.data["plan"], self.data["done"]))
        self.done_frame.pushButton3.clicked.connect(
            lambda: self.done_frame.btnFunction_convert(self.data["done"], self.data["doing"]))
        self.done_frame.pushButton4.clicked.connect(
            lambda: self.done_frame.btnFunction_convert(self.data["done"], self.data["plan"]))
        # 设定添加按钮
        self.doing_frame.btn_add.clicked.connect(lambda: self.show_add_window(self.data))
        self.plan_frame.btn_add.clicked.connect(lambda: self.show_add_window(self.data))
        self.done_frame.btn_add.clicked.connect(lambda: self.show_add_window(self.data))
        # 设定删除按钮
        self.doing_frame.btn_delete.clicked.connect(lambda: self.doing_frame.btnFunction_delete(self.data["doing"]))
        self.plan_frame.btn_delete.clicked.connect(lambda: self.plan_frame.btnFunction_delete(self.data["plan"]))
        self.done_frame.btn_delete.clicked.connect(lambda: self.done_frame.btnFunction_delete(self.data["done"]))
        if send_message:
            print("Main frames' setup is completed!")

    def frame_hideAll(self):
        """隐藏所有主要frame"""
        if send_message:
            print("Hide all frames!")
        for frame in [
            self.doing_frame, self.plan_frame, self.done_frame, self.setting_frame, self.readMe_License,
            self.curriculum_frame]:
            frame.setVisible(False)


def main():
    TimeTableApp(version=ver)


if __name__ == '__main__':
    send_message = True
    official_website = "https://github.com/Pfolg/PigFoolTimetable"
    appName = "Pig Fool Timetable"
    ver = 1.0
    main()
